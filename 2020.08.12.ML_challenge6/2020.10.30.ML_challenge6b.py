#!/usr/bin/env python
# coding: utf-8

# This script is used to read in the model generated by the 
# 2020.10.30.ML_challenge6.py script to predict the number
# of pulses in a waveform. The results are printed to the
# screen at the bottom just to show how good the model did 
# with the training set.

# In[1]:


# Read the full data file into a dataframe
# This file does not have a header so we define the column names here explicitly

import sys
import pandas as pd
import numpy as np

TRAIN_FILE  = '/home/davidl/work2/2020.08.12.ML_challenge6/Aug_2020_ML_train.csv'

# Columns in input file. First 5 are labels
names = ['ped', 'A1', 'A2', 't1', 't2']

# Next 128 are features (waveform)
for i in range(0,128): names.append('s%03d' % i)

# Read file and print how many waveforms are found
df = pd.read_csv(TRAIN_FILE, names=names)
print('Number of waveforms: %d' % len(df.index))

# Slice dataframe into 0, 1, and 2 pulse parts
vA1 = df['A1'].to_numpy()
vA2 = df['A2'].to_numpy()
Npulses = 1*(vA1>0.) + 1*(vA2>0.)
unique, counts = np.unique(Npulses, return_counts=True)
print('Number 0, 1, and 2 pulse waveforms: ' + str(counts))

# Add column with number of pulses
df['Npulses'] = Npulses

# Make slices containing only 0,1,2 identified pulses
dfno_pulses = df[(df.A1==0) & (df.A2==0)]
dfone_pulse = df[(df.A1!=0) & (df.A2==0)]
dftwo_pulse = df[(df.A1!=0) & (df.A2!=0)]


from tensorflow.keras.models import load_model
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Dense, Reshape, Flatten, Input, Lambda, Conv1D
from tensorflow.keras.optimizers import SGD, Adamax, Adadelta, Adam
from tensorflow.keras.callbacks import Callback, TensorBoard
import tensorflow.keras.backend as K
import tensorflow.keras.losses
import tensorflow as tf
import matplotlib.pyplot as plt
import matplotlib
import time

best_model = 'saved_models_part5/2020.11.02-14:30'
print('Loading model: ' + best_model)
model = load_model(best_model)


# Check the accuracy of the model in predicting the number of pulses

# In[7]:

y_true = df['Npulses'].to_numpy()
y_pred = model.predict(df.iloc[:,5:133])
y_pred = np.squeeze(np.round(y_pred))
tmp = y_pred

# Convert one-hot encoding to number of pulses.
# There is a better way to do this but, meh.
y_pred = np.array(K.argmax(y_pred))  # Only one value should be 1 so location of it is number of pulses
print(y_true)
print(y_pred)

y_diff = y_pred - y_true
testdf = pd.DataFrame({'y_diff':y_diff, 'y_true':y_true, 'y_pred':y_pred})

testdf.to_csv('Npulses_pred.csv', index=False)

N_zero_pulse = len(testdf[ (testdf['y_true']==0) ])
N_one_pulse = len(testdf[ (testdf['y_true']==1) ])
N_two_pulse = len(testdf[ (testdf['y_true']==2) ])

Ngood_zero_pulse = len(testdf[ (testdf['y_diff']==0) & (testdf['y_true']==0) ])
Ngood_one_pulse = len(testdf[ (testdf['y_diff']==0) & (testdf['y_true']==1) ])
Ngood_two_pulse = len(testdf[ (testdf['y_diff']==0) & (testdf['y_true']==2) ])

Nbad_zero_pulse = len(testdf[ (testdf['y_diff']!=0) & (testdf['y_true']==0) ])
Nbad_one_pulse = len(testdf[ (testdf['y_diff']!=0) & (testdf['y_true']==1) ])
Nbad_two_pulse = len(testdf[ (testdf['y_diff']!=0) & (testdf['y_true']==2) ])

percent_bad_zero_pulse = 100.0*Nbad_zero_pulse/(Nbad_zero_pulse+Ngood_zero_pulse)
percent_bad_one_pulse = 100.0*Nbad_one_pulse/(Nbad_one_pulse+Ngood_one_pulse)
percent_bad_two_pulse = 100.0*Nbad_two_pulse/(Nbad_two_pulse+Ngood_two_pulse)

print('Total waveforms: %d  (%d - 0 pulse, %d - 1 pulse, %d - 2 pulse)' % (len(testdf), N_zero_pulse, N_one_pulse, N_two_pulse))
print('Zero pulse waveforms: %d correct, %d incorrect (%3.1f%%)' % (Ngood_zero_pulse, Nbad_zero_pulse, percent_bad_zero_pulse))
print('One pulse waveforms: %d correct, %d incorrect (%3.1f%%)' % (Ngood_one_pulse, Nbad_one_pulse, percent_bad_one_pulse))
print('Two pulse waveforms: %d correct, %d incorrect (%3.1f%%)' % (Ngood_two_pulse, Nbad_two_pulse, percent_bad_two_pulse))

print(tmp[:7])
# In[ ]:




